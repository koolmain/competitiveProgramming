package algorithms.dsasheet.AadtyaVerma.DynamicProgramming.knapsack01;

// public var canPartition = function(A) {
//     var sumA = A.reduce((acc, curr) => acc + curr)
// 	 /* to start with, i want the number with 1 as its first element so i can mimic the previous[0]=1 state, and length of bits= the length of bits of my desired sum (sumA/2)*/
//     if (sumA % 2) 
// 		return false;
// 	let row = 1n << BigInt(sumA / 2 );
//     for (const weight of A) 
//         row = row | (row >> BigInt(weight));
//     // check the the column corresponding to my target by bitwise ANDing it with just 1
// 	// so if the first bit is 1, it will return true, otherwise false
//     return row&1n;
// };
//  {
    
}
